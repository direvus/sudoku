package sudoku

import "testing"

func TestCellRefString(t *testing.T) {
	refs := []struct{
		row int
		col int
		expect string
	}{
		{0, 0, "R1C1"},
		{0, 1, "R1C2"},
		{0, 2, "R1C3"},
		{0, 3, "R1C4"},
		{0, 4, "R1C5"},
		{0, 5, "R1C6"},
		{0, 6, "R1C7"},
		{0, 7, "R1C8"},
		{0, 8, "R1C9"},
		{1, 0, "R2C1"},
		{1, 1, "R2C2"},
		{1, 2, "R2C3"},
		{1, 3, "R2C4"},
		{1, 4, "R2C5"},
		{1, 5, "R2C6"},
		{1, 6, "R2C7"},
		{1, 7, "R2C8"},
		{1, 8, "R2C9"},
		{2, 0, "R3C1"},
		{2, 1, "R3C2"},
		{2, 2, "R3C3"},
		{2, 3, "R3C4"},
		{2, 4, "R3C5"},
		{2, 5, "R3C6"},
		{2, 6, "R3C7"},
		{2, 7, "R3C8"},
		{2, 8, "R3C9"},
		{3, 0, "R4C1"},
		{3, 1, "R4C2"},
		{3, 2, "R4C3"},
		{3, 3, "R4C4"},
		{3, 4, "R4C5"},
		{3, 5, "R4C6"},
		{3, 6, "R4C7"},
		{3, 7, "R4C8"},
		{3, 8, "R4C9"},
		{4, 0, "R5C1"},
		{4, 1, "R5C2"},
		{4, 2, "R5C3"},
		{4, 3, "R5C4"},
		{4, 4, "R5C5"},
		{4, 5, "R5C6"},
		{4, 6, "R5C7"},
		{4, 7, "R5C8"},
		{4, 8, "R5C9"},
		{5, 0, "R6C1"},
		{5, 1, "R6C2"},
		{5, 2, "R6C3"},
		{5, 3, "R6C4"},
		{5, 4, "R6C5"},
		{5, 5, "R6C6"},
		{5, 6, "R6C7"},
		{5, 7, "R6C8"},
		{5, 8, "R6C9"},
		{6, 0, "R7C1"},
		{6, 1, "R7C2"},
		{6, 2, "R7C3"},
		{6, 3, "R7C4"},
		{6, 4, "R7C5"},
		{6, 5, "R7C6"},
		{6, 6, "R7C7"},
		{6, 7, "R7C8"},
		{6, 8, "R7C9"},
		{7, 0, "R8C1"},
		{7, 1, "R8C2"},
		{7, 2, "R8C3"},
		{7, 3, "R8C4"},
		{7, 4, "R8C5"},
		{7, 5, "R8C6"},
		{7, 6, "R8C7"},
		{7, 7, "R8C8"},
		{7, 8, "R8C9"},
		{8, 0, "R9C1"},
		{8, 1, "R9C2"},
		{8, 2, "R9C3"},
		{8, 3, "R9C4"},
		{8, 4, "R9C5"},
		{8, 5, "R9C6"},
		{8, 6, "R9C7"},
		{8, 7, "R9C8"},
		{8, 8, "R9C9"},
	}
	for i := 0; i < len(refs); i++ {
		ref := CellRef{refs[i].row, refs[i].col}
		result := ref.String()
		if refs[i].expect != result {
			t.Errorf("invalid string output, expected\n%v\n\ngot\n%v", refs[i].expect, result)
		}
	}
}
